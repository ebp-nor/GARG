---
title: Simulation
subtitle: Simulation with msprime
author: Per Unneberg
date: "19 August, 2024"
format:
  nbis-course-revealjs:
    footer: GARG - Simulations
---

## Setup  {.unnumbered .unlisted visibility="hidden"}

{{< include _knitr.qmd >}}

{{< include _rlibs.qmd >}}

```{r libs }
#| echo: false
#| eval: true
#| cache: false
library(gganimate)
library(patchwork)
library(igraph)
library(ggraph)
library(tidygraph)
```

## The Wright-Fisher model and simulations

:::: {.columns}

::: {.column width="50%"}

```{r }
#| label: fig-wf-model-reproductive-success-1
#| echo: false
#| eval: true
#| fig-cap: Wright-Fisher model for 50 generations, 30 individuals
#| out-width: 70%
#| fig-align: center
set.seed(132)
g <- wright_fisher_pop(n = 30, generations = 50)
x_range <- range(vertex_attr(g, "x"))
y_range <- range(vertex_attr(g, "y"))
x1 <- x_range[1] - 1
x_range <- c(x1 - 4, x_range[2])
g %>%
  mutate(
    allele =
      ifelse(degree(., mode = "out") > 0,
        "b", "a"
      )
  ) %>%
  ggplot_wf(., fill = allele) +
  geom_segment(
    aes(
      x = x1, y = y_range[1],
      xend = x1, yend = y_range[2]
    ),
    arrow = arrow(
      length = unit(0.5, "cm"),
      type = "closed"
    )
  ) +
  annotate("text",
    label = "time",
    x = x1 - 1, y = mean(y_range),
    size = 10, angle = 90
  ) +
  annotate("text",
    label = "past",
    x = x1 - .5, y = y_range[1],
    size = 10, hjust = 1,
  ) +
  annotate("text",
    label = "present",
    x = x1 - .5, y = y_range[2],
    size = 10, hjust = 1,
  ) +
  expand_limits(x = x_range, y = y_range)
```

:::

::: {.column width="50%"}

::: {.notes}

:::

### Recap

Model of a population describing **genealogies** under the following assumptions

- discrete and non-overlapping generations
- haploid individuals or two subpopulations (males and females)
- constant population size
- all individuals are equally fit
- population has no geographical or social structure
- no recombination

::: {.fragment}

**Forward** simulation

:::

:::

::::

::: {.notes }

[p. 15 @hein2005gene] shows the fraction of genes without descendants.
Focus on the number of descendants for *one* gene *i*, which is X ~
Bin(2N, 1/2N). Since E(X)=1, for large 2N, X is almos Po(1), such that
P(no descendants) = P(X=0) = e^{-1}

Low reproductive success: forward simulations costly!

:::

## The Wright-Fisher model and simulations

:::: {.columns}

::: {.column width="50%"}

```{r }
#| label: fig-wf-model-reproductive-success-2
#| echo: false
#| eval: true
#| fig-cap: Wright-Fisher model for 50 generations, 30 individuals
#| out-width: 70%
#| fig-align: center
set.seed(132)
g <- wright_fisher_pop(n = 30, generations = 50)
x_range <- range(vertex_attr(g, "x"))
y_range <- range(vertex_attr(g, "y"))
x1 <- x_range[1] - 1
x_range <- c(x1 - 4, x_range[2])
g %>%
  mutate(
    allele =
      ifelse(degree(., mode = "out") > 0,
        "b", "a"
      )
  ) %>%
  ggplot_wf(., fill = allele) +
  geom_segment(
    aes(
      x = x1, y = y_range[1],
      xend = x1, yend = y_range[2]
    ),
    arrow = arrow(
      length = unit(0.5, "cm"),
      type = "closed"
    )
  ) +
  annotate("text",
    label = "time",
    x = x1 - 1, y = mean(y_range),
    size = 10, angle = 90
  ) +
  annotate("text",
    label = "past",
    x = x1 - .5, y = y_range[1],
    size = 10, hjust = 1,
  ) +
  annotate("text",
    label = "present",
    x = x1 - .5, y = y_range[2],
    size = 10, hjust = 1,
  ) +
  expand_limits(x = x_range, y = y_range)
```

:::

::: {.column width="50%"}

```{r }
#| label: fig-wf-model-reproductive-success-graph
#| echo: false
#| eval: true
#| cache: false
#| fig-cap:
#|    Reproductive success in percent per generation.
#| out-width: 55%
#| fig-align: center
gdf <- g %>%
  mutate(allele = ifelse(degree(., mode = "out") > 0, "b", "a")) %>%
  as.data.frame()
x <- tapply(gdf$allele, gdf$y, function(x) {
  sum(x == "b") / length(x)
})
xmean <- sprintf("%.1f%%", mean(x) * 100)
df <- data.frame(x = seq_along(x), y = x)
ggplot(subset(df, x < 50), aes(x = x, y = y * 100)) +
  geom_line(linewidth = 1.2) +
  xlab("Generation") +
  ylab("Reproductive success (%)") +
  theme(text = element_text(size = 36))
```

:::{.small}

Mean reproductive success = `r sprintf("%.1f%%", mean(x) * 100)`. Can
show for large populations P(no descendants)=$1 - e^{-1} \approx
0.632$

:::

:::

::::

::: {.notes }

[p. 15 @hein2005gene] shows the fraction of genes without descendants.
Focus on the number of descendants for *one* gene *i*, which is X ~
Bin(2N, 1/2N). Since E(X)=1, for large 2N, X is almos Po(1), such that
P(no descendants) = P(X=0) = e^{-1}

Low reproductive success: forward simulations costly!

:::

## Forward and backward simulation {.smaller}

```{r }
#| label: wright-fisher-model-graph
#| echo: false
#| eval: true
#| cache: false
set.seed(2023)
wf <- wright_fisher_pop(n = 10, generations = 16)
```

:::: {.columns}

::: {.column width="50%"}

```{r}
#| label: fig-wf-model-genealogy-forward
#| echo: false
#| eval: true
#| fig-cap:
#|    Forward simulation.
#| out-width: 60%
obj <- wf
x_range <- range(vertex_attr(obj, "x"))
y_range <- range(vertex_attr(obj, "y"))
x1 <- x_range[1] - 1
x_range <- c(x1 - 3, x_range[2])
i <- V(obj)[unlist(ego(obj, order = 16, nodes = c(152, 155, 158), mode = "in"))]
E(obj)$color <- "lightgray"
E(obj)$width <- .1
E(obj)[.to(i)]$width <- .2
E(obj)[.to(i)]$color <- "black"
ggraph(obj, layout = cbind(V(obj)$x, V(obj)$y)) +
  geom_edge_link(aes(color = color, width = width)) +
  scale_edge_color_manual(values = c(
    "black" = "black",
    "lightgray" = "black"
  )) +
  geom_node_point(fill = "black", color = "black", shape = 21, size = 3) +
  theme(legend.position = "none", axis.text.x = element_blank()) +
  scale_y_reverse() + scale_edge_width(range = c(.8, 3)) +
  geom_segment(
    aes(
      x = x1, y = y_range[1],
      xend = x1, yend = y_range[2]
    ),
    arrow = arrow(
      length = unit(0.5, "cm"),
      type = "closed"
    )
  ) +
  annotate("text",
    label = "time",
    x = x1 - 1, y = mean(y_range),
    size = 10, angle = 90
  ) +
  annotate("text",
    label = "past",
    x = x1 - .5, y = y_range[1],
    size = 10, hjust = 1,
  ) +
  annotate("text",
    label = "present",
    x = x1 - .5, y = y_range[2],
    size = 10, hjust = 1,
  ) +
  expand_limits(x = x_range, y = y_range)
```

:::

::: {.column width="50%"}

```{r}
#| label: fig-wf-model-genealogy-backward
#| echo: false
#| eval: true
#| fig-cap:
#|    Backward simulation.
#| out-width: 60%
obj <- wf
x_range <- range(vertex_attr(obj, "x"))
y_range <- range(vertex_attr(obj, "y"))
x1 <- x_range[1] - 1
x_range <- c(x1 - 3, x_range[2])
i <- V(obj)[unlist(ego(obj, order = 16, nodes = c(152, 155, 158), mode = "in"))]
E(obj)$color <- "lightgray"
E(obj)$width <- .1
E(obj)[.to(i)]$width <- .2
E(obj)[.to(i)]$color <- "black"
V(obj)[i]$allele <- "A"
ggraph(obj, layout = cbind(V(obj)$x, V(obj)$y)) +
  geom_edge_link(aes(color = color, width = width)) +
  scale_edge_color_manual(values = c(
    "black" = "black",
    "lightgray" = "lightgray"
  )) +
  geom_node_point(ggplot2::aes(fill = allele), color = "black", shape = 21, size = 3) +
  scale_fill_manual(values = list(a = "white", A = "black")) +
  theme(legend.position = "none", axis.text.x = element_blank()) +
  scale_y_reverse() + scale_edge_width(range = c(.8, 3)) +
  geom_segment(
    aes(
      x = x1, y = y_range[2],
      xend = x1, yend = y_range[1]
    ),
    arrow = arrow(
      length = unit(0.5, "cm"),
      type = "closed"
    )
  ) +
  annotate("text",
    label = "time",
    x = x1 - 1, y = mean(y_range),
    size = 10, angle = 90
  ) +
  annotate("text",
    label = "past",
    x = x1 - .5, y = y_range[1],
    size = 10, hjust = 1,
  ) +
  annotate("text",
    label = "present",
    x = x1 - .5, y = y_range[2],
    size = 10, hjust = 1,
  ) +
  expand_limits(x = x_range, y = y_range)
```

:::

::::

Simulated nodes are filled with black. Genealogy of interest is
highlighted in thick black lines.

::: {.notes}

Forward simulations: require that we keep track of the entire
population -> computationally challenging.

Backward simulations: require only tracking the sample -> quicker.
However, cannot model selection.

:::

## Why do we want simulations anyway?

::: {.incremental}

Null model
: Generate neutral null distributions to compare with observed data

Exploration
: Use to gain understanding and improve interpretation of mutational
  processes

Mathematical complexity
: No analytical solutions for linked selection and the like
  $\rightarrow$ must use simulations

Benchmarking
: Use to generate test data with known properties on which to test and
  evaluate new methods

Model training
: Generate training data for machine learning, e.g., Approximate
  Bayesian Computation (ABC) or Neural Networks (NNs)

:::

# The coalescent

## Coalescent simulations

:::: {.columns}

::: {.column width="50%"}

The coalescent simulates the genealogy of a **sample** of individuals
on which mutations are "sprinkled" according to a Poisson process.

1. Simulate ancestry (genealogy)

:::

::: {.column width="50%"}

```{r}
#| label: wf-model-genealogy-backward-1
#| echo: false
#| eval: true
#| out-width: 75%
obj <- wf
x_range <- range(vertex_attr(obj, "x"))
y_range <- range(vertex_attr(obj, "y"))
y_range <- c(y_range[1], y_range[2] + 1)
sample_nodes <- c(152, 155, 158)
i <- V(obj)[unlist(ego(obj, order = 16, nodes = sample_nodes, mode = "in"))]
V(obj)$sample <- ""
V(obj)[sample_nodes]$sample <- c(1, 2, 3)
E(obj)$color <- "lightgray"
E(obj)$width <- .1
E(obj)[.to(i)]$width <- .2
E(obj)[.to(i)]$color <- "black"
V(obj)[i]$allele <- "A"
ggraph(obj, layout = cbind(V(obj)$x, V(obj)$y)) +
  geom_edge_link(aes(color = color, width = width)) +
  scale_edge_color_manual(values = c(
    "black" = "black",
    "lightgray" = "lightgray"
  )) +
  geom_node_point(ggplot2::aes(fill = allele), color = "black", shape = 21, size = 3) +
  scale_fill_manual(values = list(a = "white", A = "black")) +
  theme(legend.position = "none", axis.text.x = element_blank()) +
  scale_y_reverse() + scale_edge_width(range = c(.8, 3)) +
  geom_node_text(aes(label = sample), size = 10, vjust = 1.5) +
  expand_limits(x = x_range, y = y_range)
```

:::

::::

::: {.notes}

NB: only the samples on the genealogy are needed, but the entire
population is shown as a means to compare with forward simulations.

:::

## Coalescent simulations

:::: {.columns}

::: {.column width="50%"}

The coalescent simulates the genealogy of a **sample** of individuals
on which mutations are "sprinkled" according to a Poisson process.

1. Simulate ancestry (genealogy)
2. Simulate mutations

:::

::: {.column width="50%"}

```{r}
#| label: wf-model-genealogy-backward-mutations
#| echo: false
#| eval: true
#| out-width: 75%
obj <- wf
x_range <- range(vertex_attr(obj, "x"))
y_range <- range(vertex_attr(obj, "y"))
y_range <- c(y_range[1], y_range[2] + 1)
sample_nodes <- c(152, 155, 158)
i <- V(obj)[unlist(ego(obj, order = 16, nodes = sample_nodes, mode = "in"))]
E(obj)$color <- "lightgray"
E(obj)$width <- .1
E(obj)$mut <- ""
E(obj)[.to(i)]$width <- .2
E(obj)[.to(i)]$color <- "black"
V(obj)[i]$allele <- "A"
V(obj)$sample <- ""
V(obj)[sample_nodes]$sample <- c(1, 2, 3)
set.seed(23)
E(obj)[sample(E(obj)[.to(i)], 5)]$mut <- "*"
ggraph(obj, layout = cbind(V(obj)$x, V(obj)$y)) +
  geom_edge_link(aes(color = color, width = width, label = mut),
    angle_calc = "along", label_size = 18
  ) +
  scale_edge_color_manual(values = c(
    "black" = "black",
    "lightgray" = "lightgray"
  )) +
  geom_node_point(ggplot2::aes(fill = allele), color = "black", shape = 21, size = 3) +
  scale_fill_manual(values = list(a = "white", A = "black")) +
  theme(legend.position = "none", axis.text.x = element_blank()) +
  scale_y_reverse() + scale_edge_width(range = c(.8, 3)) +
  geom_node_text(aes(label = sample), size = 10, vjust = 1.5) +
  expand_limits(x = x_range, y = y_range)
```

:::

::::

## Coalescent simulations

:::: {.columns}

::: {.column width="50%"}

The coalescent simulates the genealogy of a **sample** of individuals
on which mutations are "sprinkled" according to a Poisson process.

1. Simulate ancestry (genealogy)
2. Simulate mutations

<h4>Exercise</h4>

How many mutations are common to all samples? How many mutations does
sample 1 have? Sample 2?

Assuming the ancestral state is denoted `0` (prior to the *first*
generation) and the derived state `1`, what are the sequences of the
samples?

:::

::: {.column width="50%"}

```{r}
#| label: wf-model-genealogy-backward-mutations-1
#| echo: false
#| eval: true
#| out-width: 75%
obj <- wf
x_range <- range(vertex_attr(obj, "x"))
y_range <- range(vertex_attr(obj, "y"))
y_range <- c(y_range[1], y_range[2] + 1)
sample_nodes <- c(152, 155, 158)
i <- V(obj)[unlist(ego(obj, order = 16, nodes = sample_nodes, mode = "in"))]
E(obj)$color <- "lightgray"
E(obj)$width <- .1
E(obj)$mut <- ""
E(obj)[.to(i)]$width <- .2
E(obj)[.to(i)]$color <- "black"
V(obj)[i]$allele <- "A"
V(obj)$sample <- ""
V(obj)[sample_nodes]$sample <- c(1, 2, 3)
set.seed(23)
E(obj)[sample(E(obj)[.to(i)], 5)]$mut <- "*"
ggraph(obj, layout = cbind(V(obj)$x, V(obj)$y)) +
  geom_edge_link(aes(color = color, width = width, label = mut),
    angle_calc = "along", label_size = 18
  ) +
  scale_edge_color_manual(values = c(
    "black" = "black",
    "lightgray" = "lightgray"
  )) +
  geom_node_point(ggplot2::aes(fill = allele), color = "black", shape = 21, size = 3) +
  scale_fill_manual(values = list(a = "white", A = "black")) +
  theme(legend.position = "none", axis.text.x = element_blank()) +
  scale_y_reverse() + scale_edge_width(range = c(.8, 3)) +
  geom_node_text(aes(label = sample), size = 10, vjust = 1.5) +
  expand_limits(x = x_range, y = y_range)
```

:::

::::

::: {.notes}

Answers to exercise: 2 mutations are common to all samples. Sample 1
has 3 mutations, sample 2 has 4.

(arbitrarily) ordering the sites from top to bottom (oldest mutation
comes first), the sequences are:

1: 11100
2: 11101
3: 11010

:::

## Simulating genealogies [@hahn_MolecularPopulationGenetics_2019, p. 115]

:::: {.columns}

::: {.column width="50%"}

1. Start with $i=n$ chromosomes

:::

::: {.column width="50%"}

```{.tikz}
%%| label: simulate-genealogy-1
%%| echo: false
%%| eval: true
%%| out-height: 600px
%%| out-width: 500px
\begin{tikzpicture}[
          ultra thick, inner sep=0, outer sep=0,
          leaf/.style={circle,fill=black,minimum size=5pt},
          level distance=100px,
          every node/.style={font=\Large},
          ]
\draw
node[leaf] (1) {}
node[leaf, right of=1, node distance=60px] (2) {}
node[leaf, right of=2, node distance=80px] (3) {}
node[leaf, right of=3, node distance=60px] (4) {}
node[leaf, right of=4, node distance=20px] (5) {}
node at ($(1) !.5! (5)$) (mid) {}
node[above of=mid, node distance=300px] (root) {}
node at ($(1) !.3! (root) $) (7) {}
node at ($(1) !.6! (root) $) (8) {}
node at ($(5) !.1! (root) $) (6) {}
node[left of=1, node distance=40px] (t5l) {}
node[right of=5, node distance=40px] (t5r) {}
node at ($(t5l |- 6)$) (t4l) {}
node at ($(t5r |- 6)$) (t4r) {}
node at ($(t4l |- 7)$) (t3l) {}
node at ($(t4r |- 7)$) (t3r) {}
node at ($(t3l |- 8)$) (t2l) {}
node at ($(t3r |- 8)$) (t2r) {}
node at ($(t2l |- root)$) (t1l) {}
node at ($(t2r |- root)$) (t1r) {}
;

\useasboundingbox (t5l.south west) rectangle (t1r.north east);
\begin{scope}
\clip (0, 0) rectangle (0, 0);
\draw
(1) -- (root)
(5) -- (root)
(7) -- (2)
(8) -- (3)
(4) -- (6)
;

\draw
node at ($(t5r) !.5! (t4r)$) (T5) {$T_5$}
node at ($(t4r) !.5! (t3r)$) (T4) {$T_4$}
node at ($(t3r) !.5! (t2r)$) (T3) {$T_3$}
node at ($(t2r) !.5! (t1r)$) (T2) {$T_2$}
;

\draw[dotted]
(t5l) -- (t5r)
(t4l) -- (t4r)
(t3l) -- (t3r)
(t2l) -- (t2r)
(t1l) -- (t1r)
;
\end{scope}
\end{tikzpicture}
```

:::

::::

## Simulating genealogies [@hahn_MolecularPopulationGenetics_2019, p. 115]

:::: {.columns}

::: {.column width="50%"}

1. Start with $i=n$ chromosomes

2. Choose time to next coalescent event from an exponential
    distribution with parameter $\lambda=i(i-1)/2$

:::

::: {.column width="50%"}

```{.tikz}
%%| label: simulate-genealogy-2
%%| echo: false
%%| eval: true
%%| out-width: 500px
%%| out-height: 600px
\begin{tikzpicture}[
          ultra thick, inner sep=0, outer sep=0,
          leaf/.style={circle,fill=black,minimum size=5pt},
          level distance=100px,
          every node/.style={font=\Large},
          ]
\draw
node[leaf] (1) {}
node[leaf, right of=1, node distance=60px] (2) {}
node[leaf, right of=2, node distance=80px] (3) {}
node[leaf, right of=3, node distance=60px] (4) {}
node[leaf, right of=4, node distance=20px] (5) {}
node at ($(1) !.5! (5)$) (mid) {}
node[above of=mid, node distance=300px] (root) {}
node at ($(1) !.3! (root) $) (7) {}
node at ($(1) !.6! (root) $) (8) {}
node at ($(5) !.1! (root) $) (6) {}
node[left of=1, node distance=40px] (t5l) {}
node[right of=5, node distance=40px] (t5r) {}
node at ($(t5l |- 6)$) (t4l) {}
node at ($(t5r |- 6)$) (t4r) {}
node at ($(t4l |- 7)$) (t3l) {}
node at ($(t4r |- 7)$) (t3r) {}
node at ($(t3l |- 8)$) (t2l) {}
node at ($(t3r |- 8)$) (t2r) {}
node at ($(t2l |- root)$) (t1l) {}
node at ($(t2r |- root)$) (t1r) {}
node at ($(t5r) !.5! (t4r)$) (T5) {$T_5$}
;
\draw[dotted]
(t5l) -- (t5r)
(t4l) -- (t4r)
;
\begin{scope}
\clip (0, 0) rectangle (0, 0);
\draw
(1) -- (root)
(5) -- (root)
(7) -- (2)
(8) -- (3)
(4) -- (6)
;

\draw
node at ($(t5r) !.5! (t4r)$) (T5) {$T_5$}
node at ($(t4r) !.5! (t3r)$) (T4) {$T_4$}
node at ($(t3r) !.5! (t2r)$) (T3) {$T_3$}
node at ($(t2r) !.5! (t1r)$) (T2) {$T_2$}
;

\draw[dotted]
(t5l) -- (t5r)
(t4l) -- (t4r)
(t3l) -- (t3r)
(t2l) -- (t2r)
(t1l) -- (t1r)
;
\end{scope}
\end{tikzpicture}
```

:::

::::

## Simulating genealogies [@hahn_MolecularPopulationGenetics_2019, p. 115]

:::: {.columns}

::: {.column width="50%"}

1. Start with $i=n$ chromosomes

2. Choose time to next coalescent event from an exponential
    distribution with parameter $\lambda=i(i-1)/2$
3. Choose two chromosomes at random to coalesce

:::

::: {.column width="50%"}

```{.tikz}
%%| label: simulate-genealogy-3
%%| echo: false
%%| eval: true
%%| out-width: 500px
%%| out-height: 600px
\begin{tikzpicture}[
          ultra thick, inner sep=0, outer sep=0,
          leaf/.style={circle,fill=black,minimum size=5pt},
          selected/.style={circle,fill=black,minimum size=7pt},
          level distance=100px,
          every node/.style={font=\Large},
          ]
\draw
node[leaf] (1) {}
node[leaf, right of=1, node distance=60px] (2) {}
node[leaf, right of=2, node distance=80px] (3) {}
node[selected, right of=3, node distance=60px] (4) {}
node[selected, right of=4, node distance=20px] (5) {}
node at ($(1) !.5! (5)$) (mid) {}
node[above of=mid, node distance=300px] (root) {}
node at ($(1) !.3! (root) $) (7) {}
node at ($(1) !.6! (root) $) (8) {}
node at ($(5) !.1! (root) $) (6) {}
node[left of=1, node distance=40px] (t5l) {}
node[right of=5, node distance=40px] (t5r) {}
node at ($(t5l |- 6)$) (t4l) {}
node at ($(t5r |- 6)$) (t4r) {}
node at ($(t4l |- 7)$) (t3l) {}
node at ($(t4r |- 7)$) (t3r) {}
node at ($(t3l |- 8)$) (t2l) {}
node at ($(t3r |- 8)$) (t2r) {}
node at ($(t2l |- root)$) (t1l) {}
node at ($(t2r |- root)$) (t1r) {}
node at ($(t5r) !.5! (t4r)$) (T5) {$T_5$}
;
\draw[dotted]
(t5l) -- (t5r)
(t4l) -- (t4r)
;
\begin{scope}
\clip (0, 0) rectangle (0, 0);
\draw
(1) -- (root)
(5) -- (root)
(7) -- (2)
(8) -- (3)
(4) -- (6)
;

\draw
node at ($(t5r) !.5! (t4r)$) (T5) {$T_5$}
node at ($(t4r) !.5! (t3r)$) (T4) {$T_4$}
node at ($(t3r) !.5! (t2r)$) (T3) {$T_3$}
node at ($(t2r) !.5! (t1r)$) (T2) {$T_2$}
;

\draw[dotted]
(t5l) -- (t5r)
(t4l) -- (t4r)
(t3l) -- (t3r)
(t2l) -- (t2r)
(t1l) -- (t1r)
;
\end{scope}
\end{tikzpicture}
```

:::

::::

## Simulating genealogies [@hahn_MolecularPopulationGenetics_2019, p. 115]

:::: {.columns}

::: {.column width="50%"}

1. Start with $i=n$ chromosomes

2. Choose time to next coalescent event from an exponential
    distribution with parameter $\lambda=i(i-1)/2$
3. Choose two chromosomes at random to coalesce
4. Merge the two lineages and set $i \rightarrow i - 1$

:::

::: {.column width="50%"}

```{.tikz}
%%| label: simulate-genealogy-4
%%| echo: false
%%| eval: true
%%| out-width: 500px
%%| out-height: 600px
\begin{tikzpicture}[
          ultra thick, inner sep=0, outer sep=0,
          leaf/.style={circle,fill=black,minimum size=5pt},
          level distance=100px,
          every node/.style={font=\Large},
          ]
\draw
node[leaf] (1) {}
node[leaf, right of=1, node distance=60px] (2) {}
node[leaf, right of=2, node distance=80px] (3) {}
node[right of=3, node distance=60px] (4) {}
node[right of=4, node distance=20px] (5) {}
node at ($(1) !.5! (5)$) (mid) {}
node[above of=mid, node distance=300px] (root) {}
node at ($(1) !.3! (root) $) (7) {}
node at ($(1) !.6! (root) $) (8) {}
node[leaf] at ($(5) !.1! (root) $) (6) {}
node[left of=1, node distance=40px] (t5l) {}
node[right of=5, node distance=40px] (t5r) {}
node at ($(t5l |- 6)$) (t4l) {}
node at ($(t5r |- 6)$) (t4r) {}
node at ($(t4l |- 7)$) (t3l) {}
node at ($(t4r |- 7)$) (t3r) {}
node at ($(t3l |- 8)$) (t2l) {}
node at ($(t3r |- 8)$) (t2r) {}
node at ($(t2l |- root)$) (t1l) {}
node at ($(t2r |- root)$) (t1r) {}
node at ($(t5r) !.5! (t4r)$) (T5) {$T_5$}
(4) -- (6)
(5) -- (6)
;
\draw[dotted]
(t5l) -- (t5r)
(t4l) -- (t4r)
;
\begin{scope}
\clip (0, 0) rectangle (0, 0);
\draw
(1) -- (root)
(5) -- (root)
(7) -- (2)
(8) -- (3)
(4) -- (6)
;

\draw
node at ($(t5r) !.5! (t4r)$) (T5) {$T_5$}
node at ($(t4r) !.5! (t3r)$) (T4) {$T_4$}
node at ($(t3r) !.5! (t2r)$) (T3) {$T_3$}
node at ($(t2r) !.5! (t1r)$) (T2) {$T_2$}
;

\draw[dotted]
(t5l) -- (t5r)
(t4l) -- (t4r)
(t3l) -- (t3r)
(t2l) -- (t2r)
(t1l) -- (t1r)
;
\end{scope}
\end{tikzpicture}
```

:::

::::

## Simulating genealogies [@hahn_MolecularPopulationGenetics_2019, p. 115]

:::: {.columns}

::: {.column width="50%"}

1. Start with $i=n$ chromosomes
2. Choose time to next coalescent event from an exponential
    distribution with parameter $\lambda=i(i-1)/2$
3. Choose two chromosomes at random to coalesce
4. Merge the two lineages and set $i \rightarrow i - 1$
5. If $i>1$, go to step 2; if not, stop.

:::

::: {.column width="50%"}

```{.tikz}
%%| label: simulate-genealogy-5
%%| echo: false
%%| eval: true
%%| out-width: 500px
%%| out-height: 600px
\begin{tikzpicture}[
          ultra thick, inner sep=0, outer sep=0,
          leaf/.style={circle,fill=black,minimum size=5pt},
          level distance=100px,
          every node/.style={font=\Large},
          ]
\draw
node[leaf] (1) {}
node[leaf, right of=1, node distance=60px] (2) {}
node[leaf, right of=2, node distance=80px] (3) {}
node[right of=3, node distance=60px] (4) {}
node[right of=4, node distance=20px] (5) {}
node at ($(1) !.5! (5)$) (mid) {}
node[above of=mid, node distance=300px] (root) {}
node at ($(1) !.3! (root) $) (7) {}
node at ($(1) !.6! (root) $) (8) {}
node[leaf] at ($(5) !.1! (root) $) (6) {}
node[left of=1, node distance=40px] (t5l) {}
node[right of=5, node distance=40px] (t5r) {}
node at ($(t5l |- 6)$) (t4l) {}
node at ($(t5r |- 6)$) (t4r) {}
node at ($(t4l |- 7)$) (t3l) {}
node at ($(t4r |- 7)$) (t3r) {}
node at ($(t3l |- 8)$) (t2l) {}
node at ($(t3r |- 8)$) (t2r) {}
node at ($(t2l |- root)$) (t1l) {}
node at ($(t2r |- root)$) (t1r) {}
node at ($(t5r) !.5! (t4r)$) (T5) {$T_5$}
(4) -- (6)
(5) -- (6)
;
\draw[dotted]
(t5l) -- (t5r)
(t4l) -- (t4r)
;
\begin{scope}
\clip (0, 0) rectangle (0, 0);
\draw
(1) -- (root)
(5) -- (root)
(7) -- (2)
(8) -- (3)
(4) -- (6)
;

\draw
node at ($(t5r) !.5! (t4r)$) (T5) {$T_5$}
node at ($(t4r) !.5! (t3r)$) (T4) {$T_4$}
node at ($(t3r) !.5! (t2r)$) (T3) {$T_3$}
node at ($(t2r) !.5! (t1r)$) (T2) {$T_2$}
;

\draw[dotted]
(t5l) -- (t5r)
(t4l) -- (t4r)
(t3l) -- (t3r)
(t2l) -- (t2r)
(t1l) -- (t1r)
;
\end{scope}
\end{tikzpicture}
```

:::

::::

## Simulating genealogies [@hahn_MolecularPopulationGenetics_2019, p. 115]

:::: {.columns}

::: {.column width="50%"}

1. Start with $i=n$ chromosomes
2. Choose time to next coalescent event from an exponential
    distribution with parameter $\lambda=i(i-1)/2$
3. Choose two chromosomes at random to coalesce
4. Merge the two lineages and set $i \rightarrow i - 1$
5. If $i>1$, go to step 2; if not, stop.

:::

::: {.column width="50%"}

```{.tikz }
%%| label: simulate-genealogy-6
%%| echo: false
%%| eval: true
%%| out-width: 500px
%%| out-height: 600px
\begin{tikzpicture}[
          ultra thick, inner sep=0, outer sep=0,
          leaf/.style={circle,fill=black,minimum size=5pt},
          level distance=100px,
          every node/.style={font=\Large},
          ]
\draw
node[leaf] (1) {}
node[leaf, right of=1, node distance=60px] (2) {}
node[leaf, right of=2, node distance=80px] (3) {}
node[right of=3, node distance=60px] (4) {}
node[right of=4, node distance=20px] (5) {}
node at ($(1) !.5! (5)$) (mid) {}
node[above of=mid, node distance=300px] (root) {}
node at ($(1) !.3! (root) $) (7) {}
node at ($(1) !.6! (root) $) (8) {}
node[leaf] at ($(5) !.1! (root) $) (6) {}
node[left of=1, node distance=40px] (t5l) {}
node[right of=5, node distance=40px] (t5r) {}
node at ($(t5l |- 6)$) (t4l) {}
node at ($(t5r |- 6)$) (t4r) {}
node at ($(t4l |- 7)$) (t3l) {}
node at ($(t4r |- 7)$) (t3r) {}
node at ($(t3l |- 8)$) (t2l) {}
node at ($(t3r |- 8)$) (t2r) {}
node at ($(t2l |- root)$) (t1l) {}
node at ($(t2r |- root)$) (t1r) {}
node at ($(t5r) !.5! (t4r)$) (T5) {$T_5$}
node at ($(t4r) !.5! (t3r)$) (T4) {$T_4$}
(4) -- (6)
(5) -- (6)
;
\draw[dotted]
(t5l) -- (t5r)
(t4l) -- (t4r)
(t3l) -- (t3r)
;
\begin{scope}
\clip (0, 0) rectangle (0, 0);
\draw
(1) -- (root)
(5) -- (root)
(7) -- (2)
(8) -- (3)
(4) -- (6)
;

\draw
node at ($(t5r) !.5! (t4r)$) (T5) {$T_5$}
node at ($(t4r) !.5! (t3r)$) (T4) {$T_4$}
node at ($(t3r) !.5! (t2r)$) (T3) {$T_3$}
node at ($(t2r) !.5! (t1r)$) (T2) {$T_2$}
;

\draw[dotted]
(t5l) -- (t5r)
(t4l) -- (t4r)
(t3l) -- (t3r)
(t2l) -- (t2r)
(t1l) -- (t1r)
;
\end{scope}
\end{tikzpicture}
```

:::

::::

## Simulating genealogies [@hahn_MolecularPopulationGenetics_2019, p. 115]

:::: {.columns}

::: {.column width="50%"}

1. Start with $i=n$ chromosomes
2. Choose time to next coalescent event from an exponential
    distribution with parameter $\lambda=i(i-1)/2$
3. Choose two chromosomes at random to coalesce
4. Merge the two lineages and set $i \rightarrow i - 1$
5. If $i>1$, go to step 2; if not, stop.

:::

::: {.column width="50%"}

```{.tikz}
%%| label: simulate-genealogy-7
%%| echo: false
%%| eval: true
%%| out-width: 500px
%%| out-height: 600px
\begin{tikzpicture}[
          ultra thick, inner sep=0, outer sep=0,
          leaf/.style={circle,fill=black,minimum size=5pt},
          selected/.style={circle,fill=black, minimum size=7pt},
          level distance=100px,
          every node/.style={font=\Large},
          ]
\draw
node[selected] (1) {}
node[selected, right of=1, node distance=60px] (2) {}
node[leaf, right of=2, node distance=80px] (3) {}
node[right of=3, node distance=60px] (4) {}
node[right of=4, node distance=20px] (5) {}
node at ($(1) !.5! (5)$) (mid) {}
node[above of=mid, node distance=300px] (root) {}
node at ($(1) !.3! (root) $) (7) {}
node at ($(1) !.6! (root) $) (8) {}
node[leaf] at ($(5) !.1! (root) $) (6) {}
node[left of=1, node distance=40px] (t5l) {}
node[right of=5, node distance=40px] (t5r) {}
node at ($(t5l |- 6)$) (t4l) {}
node at ($(t5r |- 6)$) (t4r) {}
node at ($(t4l |- 7)$) (t3l) {}
node at ($(t4r |- 7)$) (t3r) {}
node at ($(t3l |- 8)$) (t2l) {}
node at ($(t3r |- 8)$) (t2r) {}
node at ($(t2l |- root)$) (t1l) {}
node at ($(t2r |- root)$) (t1r) {}
node at ($(t5r) !.5! (t4r)$) (T5) {$T_5$}
node at ($(t4r) !.5! (t3r)$) (T4) {$T_4$}
(4) -- (6)
(5) -- (6)
;
\draw[dotted]
(t5l) -- (t5r)
(t4l) -- (t4r)
(t3l) -- (t3r)
;
\begin{scope}
\clip (0, 0) rectangle (0, 0);
\draw
(1) -- (root)
(5) -- (root)
(7) -- (2)
(8) -- (3)
(4) -- (6)
;

\draw
node at ($(t5r) !.5! (t4r)$) (T5) {$T_5$}
node at ($(t4r) !.5! (t3r)$) (T4) {$T_4$}
node at ($(t3r) !.5! (t2r)$) (T3) {$T_3$}
node at ($(t2r) !.5! (t1r)$) (T2) {$T_2$}
;

\draw[dotted]
(t5l) -- (t5r)
(t4l) -- (t4r)
(t3l) -- (t3r)
(t2l) -- (t2r)
(t1l) -- (t1r)
;
\end{scope}
\end{tikzpicture}
```

:::

::::

## Simulating genealogies [@hahn_MolecularPopulationGenetics_2019, p. 115]

:::: {.columns}

::: {.column width="50%"}

1. Start with $i=n$ chromosomes
2. Choose time to next coalescent event from an exponential
    distribution with parameter $\lambda=i(i-1)/2$
3. Choose two chromosomes at random to coalesce
4. Merge the two lineages and set $i \rightarrow i - 1$
5. If $i>1$, go to step 2; if not, stop.

:::

::: {.column width="50%"}

```{.tikz}
%%| label: simulate-genealogy-8
%%| echo: false
%%| eval: true
%%| out-width: 500px
%%| out-height: 600px
\begin{tikzpicture}[
          ultra thick, inner sep=0, outer sep=0,
          leaf/.style={circle,fill=black,minimum size=5pt},
          selected/.style={circle,fill=black, minimum size=7pt},
          level distance=100px,
          every node/.style={font=\Large},
          ]
\draw
node (1) {}
node[right of=1, node distance=60px] (2) {}
node[leaf, right of=2, node distance=80px] (3) {}
node[right of=3, node distance=60px] (4) {}
node[right of=4, node distance=20px] (5) {}
node at ($(1) !.5! (5)$) (mid) {}
node[above of=mid, node distance=300px] (root) {}
node[leaf] at ($(1) !.3! (root) $) (7) {}
node at ($(1) !.6! (root) $) (8) {}
node[leaf] at ($(5) !.1! (root) $) (6) {}
node[left of=1, node distance=40px] (t5l) {}
node[right of=5, node distance=40px] (t5r) {}
node at ($(t5l |- 6)$) (t4l) {}
node at ($(t5r |- 6)$) (t4r) {}
node at ($(t4l |- 7)$) (t3l) {}
node at ($(t4r |- 7)$) (t3r) {}
node at ($(t3l |- 8)$) (t2l) {}
node at ($(t3r |- 8)$) (t2r) {}
node at ($(t2l |- root)$) (t1l) {}
node at ($(t2r |- root)$) (t1r) {}
node at ($(t5r) !.5! (t4r)$) (T5) {$T_5$}
node at ($(t4r) !.5! (t3r)$) (T4) {$T_4$}
(4) -- (6)
(5) -- (6)
(1) -- (7)
(2) -- (7)
;
\draw[dotted]
(t5l) -- (t5r)
(t4l) -- (t4r)
(t3l) -- (t3r)
;
\begin{scope}
\clip (0, 0) rectangle (0, 0);
\draw
(1) -- (root)
(5) -- (root)
(7) -- (2)
(8) -- (3)
(4) -- (6)
;

\draw
node at ($(t5r) !.5! (t4r)$) (T5) {$T_5$}
node at ($(t4r) !.5! (t3r)$) (T4) {$T_4$}
node at ($(t3r) !.5! (t2r)$) (T3) {$T_3$}
node at ($(t2r) !.5! (t1r)$) (T2) {$T_2$}
;

\draw[dotted]
(t5l) -- (t5r)
(t4l) -- (t4r)
(t3l) -- (t3r)
(t2l) -- (t2r)
(t1l) -- (t1r)
;
\end{scope}
\end{tikzpicture}
```

:::

::::

## Simulating genealogies [@hahn_MolecularPopulationGenetics_2019, p. 115]

:::: {.columns}

::: {.column width="50%"}

1. Start with $i=n$ chromosomes
2. Choose time to next coalescent event from an exponential
    distribution with parameter $\lambda=i(i-1)/2$
3. Choose two chromosomes at random to coalesce
4. Merge the two lineages and set $i \rightarrow i - 1$
5. If $i>1$, go to step 2; if not, stop.

:::

::: {.column width="50%"}

```{.tikz }
%%| label: simulate-genealogy-9
%%| echo: false
%%| eval: true
%%| out-width: 500px
%%| out-height: 600px
\begin{tikzpicture}[
          ultra thick, inner sep=0, outer sep=0,
          leaf/.style={circle,fill=black,minimum size=5pt},
          selected/.style={circle,fill=black, minimum size=7pt},
          level distance=100px,
          every node/.style={font=\Large},
          ]
\draw
node (1) {}
node[right of=1, node distance=60px] (2) {}
node[right of=2, node distance=80px] (3) {}
node[right of=3, node distance=60px] (4) {}
node[right of=4, node distance=20px] (5) {}
node at ($(1) !.5! (5)$) (mid) {}
node[above of=mid, node distance=300px] (root) {}
node at ($(1) !.3! (root) $) (7) {}
node[leaf] at ($(1) !.6! (root) $) (8) {}
node[leaf] at ($(5) !.1! (root) $) (6) {}
node[left of=1, node distance=40px] (t5l) {}
node[right of=5, node distance=40px] (t5r) {}
node at ($(t5l |- 6)$) (t4l) {}
node at ($(t5r |- 6)$) (t4r) {}
node at ($(t4l |- 7)$) (t3l) {}
node at ($(t4r |- 7)$) (t3r) {}
node at ($(t3l |- 8)$) (t2l) {}
node at ($(t3r |- 8)$) (t2r) {}
node at ($(t2l |- root)$) (t1l) {}
node at ($(t2r |- root)$) (t1r) {}
node at ($(t5r) !.5! (t4r)$) (T5) {$T_5$}
node at ($(t4r) !.5! (t3r)$) (T4) {$T_4$}
node at ($(t3r) !.5! (t2r)$) (T3) {$T_3$}
(4) -- (6)
(5) -- (6)
(1) -- (7)
(2) -- (7)
(7) -- (8)
(3) -- (8)
;
\draw[dotted]
(t5l) -- (t5r)
(t4l) -- (t4r)
(t3l) -- (t3r)
(t2l) -- (t2r)
;
\begin{scope}
\clip (0, 0) rectangle (0, 0);
\draw
(1) -- (root)
(5) -- (root)
(7) -- (2)
(8) -- (3)
(4) -- (6)
;

\draw
node at ($(t5r) !.5! (t4r)$) (T5) {$T_5$}
node at ($(t4r) !.5! (t3r)$) (T4) {$T_4$}
node at ($(t3r) !.5! (t2r)$) (T3) {$T_3$}
node at ($(t2r) !.5! (t1r)$) (T2) {$T_2$}
;

\draw[dotted]
(t5l) -- (t5r)
(t4l) -- (t4r)
(t3l) -- (t3r)
(t2l) -- (t2r)
(t1l) -- (t1r)
;
\end{scope}
\end{tikzpicture}
```

:::

::::

## Simulating genealogies [@hahn_MolecularPopulationGenetics_2019, p. 115]

:::: {.columns}

::: {.column width="50%"}

1. Start with $i=n$ chromosomes
2. Choose time to next coalescent event from an exponential
    distribution with parameter $\lambda=i(i-1)/2$
3. Choose two chromosomes at random to coalesce
4. Merge the two lineages and set $i \rightarrow i - 1$
5. If $i>1$, go to step 2; if not, stop.

:::

::: {.column width="50%"}

```{.tikz }
%%| label: simulate-genealogy-10
%%| echo: false
%%| eval: true
%%| out-width: 500px
%%| out-height: 600px
\begin{tikzpicture}[
          ultra thick, inner sep=0, outer sep=0,
          leaf/.style={circle,fill=black,minimum size=5pt},
          selected/.style={circle,fill=black, minimum size=7pt},
          level distance=100px,
          every node/.style={font=\Large},
          ]
\draw
node (1) {}
node[right of=1, node distance=60px] (2) {}
node[right of=2, node distance=80px] (3) {}
node[right of=3, node distance=60px] (4) {}
node[right of=4, node distance=20px] (5) {}
node at ($(1) !.5! (5)$) (mid) {}
node[leaf, above of=mid, node distance=300px] (root) {}
node at ($(1) !.3! (root) $) (7) {}
node at ($(1) !.6! (root) $) (8) {}
node at ($(5) !.1! (root) $) (6) {}
node[left of=1, node distance=40px] (t5l) {}
node[right of=5, node distance=40px] (t5r) {}
node at ($(t5l |- 6)$) (t4l) {}
node at ($(t5r |- 6)$) (t4r) {}
node at ($(t4l |- 7)$) (t3l) {}
node at ($(t4r |- 7)$) (t3r) {}
node at ($(t3l |- 8)$) (t2l) {}
node at ($(t3r |- 8)$) (t2r) {}
node at ($(t2l |- root)$) (t1l) {}
node at ($(t2r |- root)$) (t1r) {}
node at ($(t5r) !.5! (t4r)$) (T5) {$T_5$}
node at ($(t4r) !.5! (t3r)$) (T4) {$T_4$}
node at ($(t3r) !.5! (t2r)$) (T3) {$T_3$}
node at ($(t2r) !.5! (t1r)$) (T2) {$T_2$}
(4) -- (6)
(5) -- (6)
(1) -- (7)
(2) -- (7)
(7) -- (8)
(3) -- (8)
(8) -- (root)
(6) -- (root)
;
\draw[dotted]
(t5l) -- (t5r)
(t4l) -- (t4r)
(t3l) -- (t3r)
(t2l) -- (t2r)
(t1l) -- (t1r)
;
\begin{scope}
\clip (0, 0) rectangle (0, 0);
\draw
(1) -- (root)
(5) -- (root)
(7) -- (2)
(8) -- (3)
(4) -- (6)
;

\draw
node at ($(t5r) !.5! (t4r)$) (T5) {$T_5$}
node at ($(t4r) !.5! (t3r)$) (T4) {$T_4$}
node at ($(t3r) !.5! (t2r)$) (T3) {$T_3$}
node at ($(t2r) !.5! (t1r)$) (T2) {$T_2$}
;

\draw[dotted]
(t5l) -- (t5r)
(t4l) -- (t4r)
(t3l) -- (t3r)
(t2l) -- (t2r)
(t1l) -- (t1r)
;
\end{scope}
\end{tikzpicture}
```

:::

::::

## Simulating genealogies [@hahn_MolecularPopulationGenetics_2019, p. 115]

:::: {.columns}

::: {.column width="50%"}

1. Start with $i=n$ chromosomes
2. Choose time to next coalescent event from an exponential
    distribution with parameter $\lambda=i(i-1)/2$$^1$
3. Choose two chromosomes at random to coalesce
4. Merge the two lineages and set $i \rightarrow i - 1$
5. If $i>1$, go to step 2; if not, stop.

::: {.smallr}

$^1$: The exponential can be parametrized in two different ways, so
that the parameter to the function is either $\lambda$ or
$\beta=1/\lambda$.

:::

:::

::: {.column width="50%"}

```{.tikz}
%%| label: simulate-genealogy-11
%%| echo: false
%%| eval: true
%%| out-width: 500px
%%| out-height: 600px
\begin{tikzpicture}[
          ultra thick, inner sep=0, outer sep=0,
          leaf/.style={circle,fill=black,minimum size=5pt},
          selected/.style={circle,fill=black, minimum size=7pt},
          level distance=100px,
          every node/.style={font=\Large},
          ]
\draw
node (1) {}
node[right of=1, node distance=60px] (2) {}
node[right of=2, node distance=80px] (3) {}
node[right of=3, node distance=60px] (4) {}
node[right of=4, node distance=20px] (5) {}
node at ($(1) !.5! (5)$) (mid) {}
node[above of=mid, node distance=300px] (root) {}
node at ($(1) !.3! (root) $) (7) {}
node at ($(1) !.6! (root) $) (8) {}
node at ($(5) !.1! (root) $) (6) {}
node[left of=1, node distance=40px] (t5l) {}
node[right of=5, node distance=40px] (t5r) {}
node at ($(t5l |- 6)$) (t4l) {}
node at ($(t5r |- 6)$) (t4r) {}
node at ($(t4l |- 7)$) (t3l) {}
node at ($(t4r |- 7)$) (t3r) {}
node at ($(t3l |- 8)$) (t2l) {}
node at ($(t3r |- 8)$) (t2r) {}
node at ($(t2l |- root)$) (t1l) {}
node at ($(t2r |- root)$) (t1r) {}
node at ($(t5r) !.5! (t4r)$) (T5) {$T_5$}
node at ($(t4r) !.5! (t3r)$) (T4) {$T_4$}
node at ($(t3r) !.5! (t2r)$) (T3) {$T_3$}
node at ($(t2r) !.5! (t1r)$) (T2) {$T_2$}
(4) -- (6)
(5) -- (6)
(1) -- (7)
(2) -- (7)
(7) -- (8)
(3) -- (8)
(8) -- (root)
(6) -- (root)
;
\draw[dotted]
(t5l) -- (t5r)
(t4l) -- (t4r)
(t3l) -- (t3r)
(t2l) -- (t2r)
(t1l) -- (t1r)
;
\begin{scope}
\clip (0, 0) rectangle (0, 0);
\draw
(1) -- (root)
(5) -- (root)
(7) -- (2)
(8) -- (3)
(4) -- (6)
;

\draw
node at ($(t5r) !.5! (t4r)$) (T5) {$T_5$}
node at ($(t4r) !.5! (t3r)$) (T4) {$T_4$}
node at ($(t3r) !.5! (t2r)$) (T3) {$T_3$}
node at ($(t2r) !.5! (t1r)$) (T2) {$T_2$}
;

\draw[dotted]
(t5l) -- (t5r)
(t4l) -- (t4r)
(t3l) -- (t3r)
(t2l) -- (t2r)
(t1l) -- (t1r)
;
\end{scope}
\end{tikzpicture}
```

:::

::::

## Simulating genealogies [@hahn_MolecularPopulationGenetics_2019, p. 115]

:::: {.columns}

::: {.column width="50%"}

1. Start with $i=n$ chromosomes
2. Choose time to next coalescent event from an exponential
    distribution with parameter $\lambda=i(i-1)/2$$^1$
3. Choose two chromosomes at random to coalesce
4. Merge the two lineages and set $i \rightarrow i - 1$
5. If $i>1$, go to step 2; if not, stop.

::: {.smallr}

$^1$: The exponential can be parametrized in two different ways, so
that the parameter to the function is either $\lambda$ or
$\beta=1/\lambda$.

:::

:::

::: {.column width="50%"}

```{.tikz }
%%| label: fig-simulate-genealogy-end
%%| echo: false
%%| eval: true
%%| fig-align: center
%%| fig-cap:
%%|   A simulated genealogy. The $T_i$ represent the
%%|   waiting time when the state has $i$ chromosomes.
%%| out-width: 60%
\begin{tikzpicture}[
          ultra thick, inner sep=0, outer sep=0,
          leaf/.style={circle,fill=black,minimum size=5pt},
          level distance=100px,
          every node/.style={font=\Large},
          ]
\draw
node (1) {}
node[right of=1, node distance=60px] (2) {}
node[right of=2, node distance=80px] (3) {}
node[right of=3, node distance=60px] (4) {}
node[right of=4, node distance=20px] (5) {}
node at ($(1) !.5! (5)$) (mid) {}
node[above of=mid, node distance=300px] (root) {}
node at ($(1) !.3! (root) $) (7) {}
node at ($(1) !.6! (root) $) (8) {}
node at ($(5) !.1! (root) $) (6) {}
node[left of=1, node distance=40px] (t5l) {}
node[right of=5, node distance=40px] (t5r) {}
node at ($(t5l |- 6)$) (t4l) {}
node at ($(t5r |- 6)$) (t4r) {}
node at ($(t4l |- 7)$) (t3l) {}
node at ($(t4r |- 7)$) (t3r) {}
node at ($(t3l |- 8)$) (t2l) {}
node at ($(t3r |- 8)$) (t2r) {}
node at ($(t2l |- root)$) (t1l) {}
node at ($(t2r |- root)$) (t1r) {}
;

\draw
(1) -- (root)
(5) -- (root)
(7) -- (2)
(8) -- (3)
(4) -- (6)
;

\draw
node at ($(t5r) !.5! (t4r)$) (T5) {$T_5$}
node at ($(t4r) !.5! (t3r)$) (T4) {$T_4$}
node at ($(t3r) !.5! (t2r)$) (T3) {$T_3$}
node at ($(t2r) !.5! (t1r)$) (T2) {$T_2$}
;

\draw[dotted]
(t5l) -- (t5r)
(t4l) -- (t4r)
(t3l) -- (t3r)
(t2l) -- (t2r)
(t1l) -- (t1r)
;
\end{tikzpicture}
```

:::

::::

## Some properties of the tree {.smaller}

:::: {.columns}

::: {.column width="50%"}

```{.tikz }
%%| label: fig-genealogy-properties
%%| echo: false
%%| eval: true
%%| fig-cap:
%%|   A coalescent tree with numbered nodes. Nodes 1-5 correspond
%%|   to the samples and are leaves. The internal nodes 6-8 (and the
%%|   unlabelled root) are ancestral chromosomes (unsampled). The
%%|   $T_i$ represent the waiting time when the state has $i$ chromosomes,
%%|   whereas $\tau_i$ correspond to the branch length from node $i$
%%|   to its parent.
%%| fig-align: center
%%| out-width: 60%
\begin{tikzpicture}[
          ultra thick, inner sep=0, outer sep=0,
          leaf/.style={circle,fill=black,minimum size=5pt},
          level distance=100px,
          every node/.style={font=\Large},
          every label/.style={font=\sffamily\Large}
          ]

\draw
node[leaf, label={[yshift=-25pt]1}] (1) {1}
node[leaf, label={[yshift=-25pt]2}, right of=1, node distance=60px] (2) {2}
node[leaf, label={[yshift=-25pt]3}, right of=2, node distance=80px] (3) {3}
node[leaf, label={[yshift=-25pt]4}, right of=3, node distance=60px] (4) {4}
node[leaf, label={[yshift=-25pt]5}, right of=4, node distance=20px] (5) {5}
node at ($(1) !.5! (5)$) (mid) {}
node[above of=mid, node distance=300px] (root) {}
node[leaf, label={[xshift=10pt]7}] at ($(1) !.3! (root) $) (7) {7}
node[leaf, label={[xshift=10pt]8}] at ($(1) !.6! (root) $) (8) {8}
node[leaf, label={[xshift=10pt]6}] at ($(5) !.1! (root) $) (6) {6}
node[left of=1, node distance=40px] (t5l) {}
node[right of=5, node distance=40px] (t5r) {}
node at ($(t5l |- 6)$) (t4l) {}
node at ($(t5r |- 6)$) (t4r) {}
node at ($(t4l |- 7)$) (t3l) {}
node at ($(t4r |- 7)$) (t3r) {}
node at ($(t3l |- 8)$) (t2l) {}
node at ($(t3r |- 8)$) (t2r) {}
node at ($(t2l |- root)$) (t1l) {}
node at ($(t2r |- root)$) (t1r) {}
;

\draw
(1) -- (root)
(5) -- (root)
(7) -- (2)
(8) -- (3)
(4) -- (6)
;

\draw
node at ($(1) !.5! (7) - (10pt, 0)$) () {$\mathbf{\tau_1}$}
node at ($(2) !.5! (7) - (10pt, 0)$) () {$\mathbf{\tau_2}$}
node at ($(3) !.45! (8) - (10pt, 0)$) () {$\mathbf{\tau_3}$}
node at ($(4) !.5! (6) - (10pt, 0)$) () {$\mathbf{\tau_4}$}
node at ($(5) !.5! (6) + (10pt, 0)$) () {$\mathbf{\tau_5}$}
node at ($(6) !.5! (root) + (10pt, 0)$) () {$\mathbf{\tau_6}$}
node at ($(7) !.5! (8) - (10pt, 0)$) () {$\mathbf{\tau_7}$}
node at ($(8) !.5! (root) - (10pt, 0)$) () {$\mathbf{\tau_8}$}
;


\draw
node at ($(t5r) !.5! (t4r)$) (T5) {$T_5$}
node at ($(t4r) !.5! (t3r)$) (T4) {$T_4$}
node at ($(t3r) !.5! (t2r)$) (T3) {$T_3$}
node at ($(t2r) !.5! (t1r)$) (T2) {$T_2$}
;

\draw[dotted]
(t5l) -- (t5r)
(t4l) -- (t4r)
(t3l) -- (t3r)
(t2l) -- (t2r)
(t1l) -- (t1r)
;
\end{tikzpicture}
```

:::

::: {.column width="50%"}

Expected waiting time to coalesce when $i$ lineages:

$$
E(T_i) = \frac{2}{i(i-1)}
$$

Branch lengths can be derived from waiting times. For instance,
$\tau_1=\tau_2=T_5+T_4$ and $\tau_4=\tau_5=T_5$

Time to the **most recent common ancestor (MRCA)** is sum of wating
times:

$$
T_{MRCA} = \sum_{i=2}^n T_i
$$

with expected value

$$
E(T_{MRCA}) = \sum_{i=2}^nE(T_i) = 2\left(1 - \frac{1}{n}\right)
$$

The expected **total tree height** is

$$
E(T_{total}) = \sum_{i=2}^n iE(T_i) = 2\sum_{i=2}^n\frac{1}{i-1}
$$

:::

::::

::: {.notes}

Note that the parametrization is in 2N generations (continuous time
approximation); some use N, others 4N, and so on.

Expected waiting time: the first expression follows from the fact that
the waiting time, given $i$ chromosomes, is exponentially distributed
with parameter $\lambda=i(i-1)/2$. For an exponentially distributed
variable $X$, the expected value is simply $E(X)=1/\lambda$.

Other relations are most easily derived by studying the tree and
summing up relevant branches or time intervals.

:::

## Coalescent simulations vary in topology and height {.smaller}

```{python }
#| label: msprime-simulations
#| cache: false
#| echo: true
#| eval: true
#| code-fold: true
import msprime
seeds = [12, 15, 16, 34, 63, 30]
trees = [msprime.sim_ancestry(3, random_seed=x) for x in seeds]
```

:::{}

```{python }
#| label: fig-coalescent-trees-with-msprime
#| echo: false
#| eval: true
#| fig-format: svg
#| out-width: 80%
#| output: asis
#| fig-cap:
#|     Examples of coalescent simulations. Note the variation in tree
#|     topology and height.
kwargs = dict(x_axis=False, node_labels={},
              symbol_size=0, style=".edge {stroke-width: 2px}",
              root_svg_attributes={"id": "msprime-simulation"})
ymax = 450
tmrca = [ts.node(ts.first().root).time for ts in trees]
for i, ts in enumerate(trees):
    y = tmrca[i] / max(tmrca) * ymax
    print(ts.draw_svg(size=(170, y), **kwargs))
```

:::

Examples of coalescent simulations. Note the variation in tree
topology and height.

## Diminishing returns of adding more samples

:::{}

```{r }
#| label: fig-coalescent-diminishing-returns
#| echo: false
#| eval: true
#| fig-width: 12
#| fig-height: 6
#| fig-align: center
#| out-width: 80%
#| fig-cap:
#|     Dependence of $E[T_{MRCA}]$ and $E[T_{total}]$ on the
#|     sample size n. Already at low values of n the value of
#|     $E[T_{MRCA}]$ is close to its asymptotic value, which has
#|     practical consequences for the measurement of DNA variation.
#|     Adapted from @wakeley_CoalescentTheoryIntroduction_2008,
#|     Fig. 3.3.
n <- 20
t_total <- function(n) {
  2 * sum(1 / (seq(2, n) - 1))
}
t_mrca <- function(n) {
  2 * (1 - 1 / n)
}

data <- data.frame(
  y = c(
    c(0, unlist(lapply(2:n, t_total))),
    c(0, unlist(lapply(2:n, t_mrca)))
  ),
  x = c(1:n, 1:n),
  stat = c(rep("E[T_total]", n), rep("E[T_MRCA]", n))
)
ggplot(data, aes(x = x, y = y, linetype = factor(stat))) +
  geom_line(linewidth = 1.2) +
  xlab("n") +
  ylab("") +
  guides(linetype = guide_legend(title = "Statistic"))
```

:::

::: {.notes}

Adding a sample only adds $2/n$ to the total tree length. Also, adding
a sample will add little to $T_{MRCA}$, or equivalently, will most
likely add a very recent coalescent event to the tree for large enough
$n$. Note that $n=20$ here is equivalent to 10 diploid individuals.

:::

## Adding mutations

:::: {.columns}

::: {.column width="50%"}

```{.tikz}
%%| label: fig-add-mutations
%%| echo: false
%%| eval: true
%%| out-width: 500px
%%| out-height: 500px
%%| fig-cap:
%%|   Adding mutations on a coalescent genealogy.
\begin{tikzpicture}[
          ultra thick, inner sep=0, outer sep=0,
          leaf/.style={circle,fill=black,minimum size=10pt},
          level distance=100px,
          every node/.style={font=\Large},
          ]
\draw
node (1) {}
node[right of=1, node distance=120px] (2) {}
node[right of=2, node distance=80px] (3) {}
node[right of=3, node distance=80px] (4) {}
node at ($(1) !.5! (4)$) (mid) {}
node[above of=mid, node distance=300px] (root) {}
node at ($(4) !.6! (root) $) (6) {}
node at ($(2) !.5! (6) $) (5) {}
node[above of=root, node distance=10px, outer sep=10px] (ancestral) {00000}
node[below of=1, rotate=60, node distance=8px, anchor=south east] (l1) {11000}
node[below of=2, rotate=60, node distance=8px, anchor=south east] (l2) {00110}
node[below of=3, rotate=60, node distance=8px, anchor=south east] (l3) {00100}
node[below of=4, rotate=60, node distance=8px, anchor=south east] (l4) {00001}
node at ($(1) !.33! (root) - (.5, 0)$) (m1l) {0}
node at ($(1) !.33! (root) + (.5, 0)$) (m1r) {1}
node at ($(1) !.67! (root) - (.5, 0)$) (m2l) {0}
node at ($(1) !.67! (root) + (.5, 0)$) (m2r) {1}
node at ($(2) !.5! (5) - (.5, 0)$) (m3l) {0}
node at ($(2) !.5! (5) + (.5, 0)$) (m3r) {1}
node at ($(5) !.5! (6) - (.5, 0)$) (m4l) {0}
node at ($(5) !.5! (6) + (.5, 0)$) (m4r) {1}
node at ($(4) !.5! (6) - (.5, 0)$) (m5l) {0}
node at ($(4) !.5! (6) + (.5, 0)$) (m5r) {1}
;
\draw
(1) -- (root)
(4) -- (root)
(2) -- (6)
(3) -- (5);
\draw[>=latex, ->] (m1l) -- (m1r);
\draw[>=latex, ->] (m2l) -- (m2r);
\draw[>=latex, ->] (m3l) -- (m3r);
\draw[>=latex, ->] (m4l) -- (m4r);
\draw[>=latex, ->] (m5l) -- (m5r);

\end{tikzpicture}
```

:::

::: {.column width="50%"}

Mutations are added by placing them on branches, where the probability
of ending up on a branch $\tau_i$ is equal to its normalized
length, where normalization is by the total tree branch length:

$$
P(\text{mutation on branch }i) = \frac{\tau_i}{\sum_j\tau_j} =
\frac{\tau_i}{T_{total}}
$$

The total number of segregating sites $S$ to be thrown on the tree is
modelled as a [Poisson random
variable](https://en.wikipedia.org/wiki/Poisson_distribution) which
expresses the probability of a given number of events in time $t$:

$$
S = Po(\theta/2T_{total})
$$

:::

::::

::: {.notes}

Sofar we have looked at genealogies; now add mutations.

In words: sample a number of segregating sites from the Poisson
distribution, and "sprinkle" them on the tree.

The parametrization $\lambda = \theta / 2$ is defined with reference
to the average heterozygosity between two sequences being $\theta$ (by
Tajima; see @wakeley_CoalescentTheoryIntroduction_2008, p. 92)

:::

## The coalescent and diversity {.smaller}

:::: {.columns}

::: {.column width="50%"}

::: {.dna}

| 1 | 2     | 3 | 4 | 5     | 6 | 7 | 8     | 9 | 10 | 11    | 12 | 13    | 14 | 15    |
|:-:|:-----:|:-:|:-:|:-----:|:-:|:-:|:-----:|:-:|:--:|:-----:|:--:|:-----:|:--:|:-----:|
| T | T     | A | C | A     | A | T | **C** | C | G  | A     | T  | C     | G  | T     |
| T | T     | A | C | **G** | A | T | G     | C | G  | **C** | T  | C     | G  | T     |
| T | **C** | A | C | A     | A | T | G     | C | G  | A     | T  | **G** | G  | **A** |
| T | T     | A | C | **G** | A | T | G     | C | G  | **C** | T  | C     | G  | T     |
|   | *     |   |   | *     |   |   | *     |   |    | *     |    | *     |    | *     |

: {tbl-colwidths="[6,6,6,6,6,6,6,6,6,6,6,6,6,6,6]"}

:::

::: {.fragment}

<!-- markdownlint-disable MD013 -->

$$
\begin{align}
\pi & = \sum_{j=1}^S h_j = \sum_{j=1}^{S} \frac{n}{n-1}\left(1 - \sum_i p_i^2 \right) \\
& \stackrel{S=6,\\ n=4}{=} \sum_{j=1}^{6} \frac{4}{3}\left(1 - \sum_i p_i^2\right) \\
& = \frac{4}{3}\left(\mathbf{\color{#a7c947}{4}}\left(1-\frac{1}{16}-\frac{9}{16}\right) + \mathbf{\color{#a7c947}{2}}\left(1 - \frac{1}{4} - \frac{1}{4}\right)\right) = \frac{10}{3}
\end{align}
$$

<!-- markdownlint-enable MD013 -->

:::

:::

::: {.column width="20%" .fragment}

```{.tikz}
%%| label: coalescent-tree-dna-variation-representation
%%| echo: false
%%| eval: true
%%| out-width: 80%
\begin{tikzpicture}[outer sep=0, inner sep=0, thick,
                    node distance=5px, every node/.style={font=\ttfamily}]
\tikzstyle{mut} = [circle, minimum height=0.2cm, fill=gray, draw];
\draw
node (1) at (0, 0) {}
node (2) at (1, 0) {}
node (3) at (2, 0) {}
node (4) at (3, 0) {}
node (5) at ($(1) !.5! (2) + (0, 2)$) {}
node (6) at ($(1-|5) !.5! (3) + (0, 3)$) {}
node (7) at ($(1-|6) !.5! (4) + (0, 5)$) {}
node[above of=7, anchor=south] (rootl) {000000}
node[rotate=45, below left of=1, anchor=north east] (1l) {010100}
node[rotate=45, below left of=2, anchor=north east] (2l) {010100}
node[rotate=45, below left of=3, anchor=north east] (3l) {001000}
node[rotate=45, below left of=4, anchor=north east] (4l) {100011}
;

\draw
(1) -- (5)
(2) -- (5)
(5) -- (6)
(3) -- (6)
(6) -- (7)
(4) -- (7)
node[mut] (m1) at ($(5) !.33! (6)$) {}
node[mut] (m2) at ($(5) !.67! (6)$) {}
node[mut] (m3) at ($(3) !.5! (6)$) {}
node[mut] (m4) at ($(4) !.25! (7)$) {}
node[mut] (m5) at ($(4) !.5! (7)$) {}
node[mut] (m6) at ($(4) !.75! (7)$) {}
;
\end{tikzpicture}
```

:::

::: {.column width="30%" .fragment}

```{.tikz}
%%| label: tree-site-frequency-spectrum-graph
%%| echo: false
%%| eval: true
%%| out-width: 80%
%% https://tex.stackexchange.com/questions/123866/histogram-with-tikz
\begin{tikzpicture}[ybar interval]
\tikzstyle{tick}=[font=\scriptsize];
\tikzstyle{label}=[font=\small];
  \draw[fill=blue!60!black, draw=blue!60!black]
plot coordinates{(0,.8) (1,.4) (2, 0) (3, 0)};
\draw[->] (-0.2, 0) -- (3.2, 0) node[right] {$x$};
\draw[->] (0, -0.2) -- (0, 1.2) node[above] {$y$};
\node[tick] at (0.5, -0.3) {1};
\node[tick] at (1.5, -0.3) {2};
\node[tick] at (2.5, -0.3) {3};
\node[tick] at (1.5, -0.6) {Allele frequency};
\node[tick, rotate=90] at (-0.4, .5) {Proportion};
\end{tikzpicture}
```

::: {.fragment}

In this notation one can show that $\pi$, the nucleotide diversity, is

$$
\begin{align}
\pi & = \frac{\sum_{i=1}^{n-1}i(n-i)\xi_i}{n(n-1)/2} \\
& \stackrel{n=4}{=} \frac{1*(4-1)*4 + 2*(4-2)*2}{6}
= \frac{10}{3}
\end{align}
$$

:::

:::

::::

::: {.fragment}

Many statistical quantities can be related to the **site frequency
spectrum** (**SFS**), which is a summary of the frequencies of the
segregating sites. Let $\xi_i$ be the number of chromosomes in the
sample with $i$ minor alleles. In the example above we have $S=6$
mutations on $n=4$ chromosomes.

:::

## The impact of topology on the SFS {.smaller}

:::: {.columns}

::: {.column width="50%"}

<!-- markdownlint-disable MD013 -->

:::: {style="display: grid; grid-template-columns: 200px 200px; grid-row-gap: 0px; grid-column-gap: 40px;"}

:::{}

*Neutral*

```{python }
#| label: msprime-trees-neutral
#| echo: false
#| eval: true
#| fig-format: svg
#| output: asis
import treeviz
print(treeviz.tree_topology(model="neutral", svgid="neutral", size=(200, 250)))
```

:::

:::{}

*Expansion*

```{python }
#| label: msprime-trees-expansion
#| echo: false
#| eval: true
#| fig-format: svg
#| output: asis
import treeviz
print(treeviz.tree_topology(model="expansion", svgid="expansion", size=(200, 250)))
```

:::

:::{}

*Bottleneck*

```{python }
#| label: msprime-trees-bottleneck
#| echo: false
#| eval: true
#| fig-format: svg
#| output: asis
import treeviz
print(treeviz.tree_topology(model="bottleneck", svgid="bottleneck", size=(200, 250)))
```

:::

:::{}

*Selection*

```{python }
#| label: msprime-trees-selection
#| echo: false
#| eval: true
#| fig-format: svg
#| output: asis
import treeviz
print(treeviz.tree_topology(model="selection", svgid="selection", size=(200, 250)))
```

:::

::::

<!-- markdownlint-enable MD013 -->

:::

::: {.column width="50%"}

<!-- markdownlint-disable MD013 -->

![The SFS under neutrality and selection](assets/images/nielsen-fig2-2005.jpeg){#fig-sfs-neutrality-selection width=450}

<!-- markdownlint-enable MD013 -->

Many tests for selection are based on the SFS which in turn is
influenced by the topology of the tree.

:::

::::

::: {.notes }

Take home: topologies influence shape of SFS

### Example: Tajima's D

Tests common versus rare alleles. Numerator compares nucleotide
diversity $\pi$ to Watterson's theta, $\theta_W$.

D < 0
: recent population increase *or* positive selection

D > 0
: population contraction *or* balancing selection

:::

# Exercise on the coalescent {.unnumbered .unlisted}

## Bibliography {.unnumbered .unlisted .smaller}

::: { #refs }
:::
